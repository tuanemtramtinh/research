# Multi-Agent Use Case and Scenario Generation Framework

This repository implements a web-based multi-agent pipeline that transforms natural language requirements into structured use case models and detailed use case scenarios.

By integrating Large Language Models (LLMs) with rule-based validation and multi-agent orchestration, the system ensures structural consistency and semantic quality through automated refinement and evaluation.

The framework is designed for research purposes and supports usecase and scenario generation, multi-criteria evaluation, and human-in-the-loop validation.

---

## System Overview

The system operates as a state-based graph pipeline with a shared Pool Data repository.

It consists of two sequential agents:

- Requirement Parsing Agent
- Scenario Generation Agent

---

## Workflow

The overall workflow includes three major stages:

### 1. Requirement Parsing and Use Case Generation

- Analyze natural language user stories
- Extract:
  - Actors
  - Use cases
  - Inter-use-case relationships (e.g., `<<include>>`, `<<extend>>`)
- Produce structured use case specifications

### 2. Scenario Generation and Multi-Criteria Evaluation

- Generate detailed use case scenarios
- Evaluate scenarios using multi-judge reasoning across:
  - Completeness
  - Correctness
  - Relevance
- Trigger controlled regeneration when quality thresholds are not satisfied

### 3. Human-in-the-Loop (HITL) Interaction

- Users review generated use cases and scenarios via a web interface
- Validate correctness and domain alignment
- Provide feedback before final approval

---

## Research Objective

This framework aims to improve automated understanding of natural language requirements and enhance the quality of generated use case specifications and scenarios through multi-agent reasoning and structured evaluation.

## Setup and Repository Structure

This repository is a research backend's framework that is split into two main parts:

- **`src/`**: Core logic framework, **without** the _human-in-the-loop_ (HITL) implementation yet.
- **`server/`**: Backend server with a full _human-in-the-loop_ implementation.

Each part has slightly different ways to run and separate `.env` configuration (explained below).

---

## 1. Python Environment Setup

Requirements:

- Python 3.x (recommended 3.10+)
- `pip` installed

### 1.1. Create a virtual environment

From the **project root directory**, open a terminal and run:

#### Windows (PowerShell / CMD)

```bash
python -m venv .venv
```

Activate the virtual environment:

- **PowerShell**:

```bash
.\.venv\Scripts\Activate.ps1
```

- **CMD**:

```bash
.\.venv\Scripts\activate.bat
```

#### Linux / macOS (bash / zsh)

```bash
python3 -m venv .venv
source .venv/bin/activate
```

Every time you open a new terminal, activate the virtual environment again before running commands.

### 1.2. Install dependencies

After activating the virtual environment and while in the **project root directory**, install the required packages:

```bash
pip install -r requirements.txt
```

(If the project uses separate `requirements` files for `src` and `server`, adjust the path to the correct `requirements` file accordingly.)

---

## 2. Directory Structure

At a high level, the **project root directory** looks like this:

```text
root/
  ├─ src/         # Core logic framework, without HITL
  ├─ server/      # Backend with human-in-the-loop implementation
  ├─ inputs/      # Test inputs
  ├─ manual_diagram/  # Expert-drawn use case diagrams
  ├─ outputs_sca/     # Scenario Generation Agent outputs for tested inputs
  ├─ outputs_rpa/     # Requirement Parsing Agent outputs for tested inputs
  ├─ .env.example # Environment variable template for src
  └─ README.md
```

Details:

- **`src/`**
  - Contains the core framework logic structure (pipelines, core modules, etc.).
  - Currently **does not** include the human-in-the-loop implementation.
  - This part uses the `.env` file at the **project root directory**.

- **`server/`**
  - Contains the backend server (API / service) with a human-in-the-loop implementation.
  - Has its own `.env.example` file inside the `server/` directory.
  - This part uses a `.env` file placed **inside the `server/` folder**.

- **`inputs/`**
  - Contains the input artifacts used for testing the framework and agents.
  - These inputs are the source data that both the Scenario Generation Agent and the Requirement Parsing Agent operate on.

- **`manual_diagram/`**
  - Contains expert-drawn use case diagrams.
  - These diagrams serve as the human-created ground truth or reference when evaluating and comparing the agents’ outputs.

- **`outputs_sca/`**
  - Contains the outputs generated by the **Scenario Generation Agent (SCA)** based on the test inputs in `inputs/`.
  - Each file typically corresponds to one input and describes the generated scenarios/use cases.

- **`outputs_rpa/`**
  - Contains the outputs generated by the **Requirement Parsing Agent (RPA)** based on the same test inputs in `inputs/`.
  - Each file typically corresponds to one input and describes the parsed/structured requirements.

---

## 3. `.env` Configuration

### 3.1. Running the `src/` part

1. In the **project root directory**, create a new `.env` file:

```bash
cp .env.example .env
```

Or create it manually and copy the content from `.env.example`.

2. Open `.env` and fill in all required environment variables (API keys, paths, model parameters, etc.).

> **Note**: The `src/` part **requires** the `.env` file at the **project root directory** to run correctly.

### 3.2. Running the `server/` part

1. Move into the `server/` directory:

```bash
cd server
```

2. Create a `.env` file in `server/` based on the template:

```bash
cp .env.example .env
```

3. Edit the `.env` file inside `server/` with your desired configuration (port, DB connection, API keys, etc.).

> **Note**: The `.env` file inside `server/` is **independent** from the `.env` at the root of `main/`.

---

## 4. How to Run

### 4.1. Run the framework logic in `src/`

Assuming you are in the **project root directory** and the virtual environment is activated:

```bash
python -m src.<main_module_name>
```

Or follow a specific entry point inside `src/`, for example:

```bash
python -m src.main
```

You can also run the RPA graph independently for experimentation:

```bash
python -m src.graphs.rpa_graph
```

Make sure that:

- `.env` has been created at the **project root directory** from `.env.example`.
- All dependencies have been installed in the virtual environment.

### 4.2. Run the backend server (with HITL)

From the **project root directory**:

```bash
cd server
```

Make sure that:

- The virtual environment (created in step 1) is activated.
- A `.env` file has been created in `server/` from `.env.example`.

Then start the server, for example (depending on the framework you use, adjust as needed):

```bash
fastapi dev main.py
```

See the code inside `server/` for more details if there is a dedicated entry point or documentation file.

---

## 5. Additional Notes

- Do **not** commit `.env` files (they should already be ignored via `.gitignore`).
- If you change the structure of `src/` or `server/`, please update this README so that other team members can easily set up and run the project.
